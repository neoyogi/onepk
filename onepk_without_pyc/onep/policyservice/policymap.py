# 2015.02.05 17:22:53 IST
from onep.policyservice.classmap import ClassMap, ClassResultAsync
from onep.policyservice.caps import PolicyCapabilities
from onep.policyservice.caps import PolicyCapabilitiesType
from onep.PolicyBulkIDL.ttypes import PmapIDL, PolicyFilterIDL
from onep.policyservice.match import MatchType
from onep.policyservice.match import Match
from onep.policyservice.action import Action
from onep.policyservice.action import ActionType
from onep.policyservice.action import Mark
from onep.policyservice.target import Target
from onep.policyservice.statistics import PolicyStatistics
from onep.PolicyBulkIDL.ttypes import EntryIDL
from onep.core.util.Enum import *
from onep.core.util.OnepArgumentTypeValidate import *
from onep.core.exception.OnepIllegalArgumentException import OnepIllegalArgumentException
import logging
from onep.core.util.OnepStatus import OnepStatus
import types
from onep.policyservice import StorageType
from onep.policyservice import StatisticCategory
from onep.core.exception.OnepException import OnepNotSupportedException
from onep.interfaces import NetworkInterface
from onep.core.event.EventListener import EventListener
from onep.core.event.AsyncMsg import AsyncMsg
from abc import ABCMeta, abstractmethod

class PolicyMap(object):
    """
        PolicyMap class.
        
        This PolicyMap class contains a hierarchy of objects that define class map,
        match and action objects for applying policies to targets.  Capability
        specifications are contained in the PolicyCapability class and the policy
        can be associated with multiple targets. Adding and removing Action(s),
        Match(es), and Entries will only be applied to the local copy of this Class.
        The BulkService class must be used to submit those changes on the Network Element.
    
        Class variables
        
        capabilities - PolicyCapabilities class
        
        storage_type - StorageType enum (default TRANSIENT)
        
        name         - polcy name (default auto-generated by element)
        
        op_id        - Integer set by application for async operations (default None)
        
        @undocumented: create_entry
        @undocumented: get_entry_list
        @undocumented: handle
        @undocumented: result_code
        @undocumented: result_text
        """

    Order = enum('ONEP_POLICY_ORDER_END', 'ONEP_POLICY_ORDER_BEFORE', 'ONEP_POLICY_ORDER_DEFAULT', 'ONEP_POLICY_ORDER_SEQUENCE')
    PolicyOperation = enum(ONEP_POLICY_OP_CREATE=0, ONEP_POLICY_OP_MODIFY=1, ONEP_POLICY_OP_DELETE=2, ONEP_POLICY_OP_ACTIVATE=3, ONEP_POLICY_OP_DEACTIVATE=4, ONEP_POLICY_OP_GET=5, ONEP_POLICY_OP_GET_STATS=6, ONEP_POLICY_OP_REMOVE_STATS=7, ONEP_POLICY_OP_REPLACE_ALL_ACTIONS=8, ONEP_POLICY_OP_REPLACE_ALL_MATCHES=9, ONEP_POLICY_OP_REPLACE_ALL_ACTIONS_MATCHES=10)

    def __init__(self, capabilities, name = None, storage_type = StorageType.TRANSIENT):
        """ Constructs an instance of PolicyMap with specified capability.
        
        @param capabilities: Policy Capability.
        @type capabilities: L{PolicyCapabilities<onep.policyservice.PolicyCapabilities.PolicyCapabilities>}
        
        @raise OnepIllegalArgumentException: If constructor parameter is invalid.
        """
        self.log = logging.getLogger(__name__)
        validate(capabilities, PolicyCapabilities)
        if not StorageType._is_valid(storage_type):
            raise OnepInvalidArgumentException('Invalid storage type')
        table = [ table for table in capabilities.all.tables if table.type == capabilities.policy_type ]
        if not table:
            raise OnepNotSupportedException('Policy type %s' % PolicyCapabilitiesType.enumval(capabilities.policy_type))
        self.storage_type = storage_type
        self.capabilities = capabilities
        self._element = capabilities.network_element
        self._actions = table[0].actions
        self.name = name
        self._handle = 0
        self._entries = []
        self._result = None
        self._op_code = None
        self.op_id = None



    @property
    def handle(self):
        return self._handle



    @handle.setter
    def handle(self, handle):
        self._handle = handle



    def _get_result_code(self):
        if self._result:
            entrs = self.get_entry_list()
            res = 0
            if self._result.resultCode:
                res = self._result.resultCode
            if not entrs:
                return res
            for e in entrs:
                if e._entry_result is not None:
                    self.log.debug('Entry result text ' + OnepStatus.enumval(e._entry_result.resultCode))
                    if e._entry_result.resultCode:
                        self.log.error('Entry result text ' + OnepStatus.enumval(e._entry_result.resultCode))
                        res = e._entry_result.resultCode
                    if e._entry_result.cmapResult:
                        self.log.debug('Class-map result ' + OnepStatus.enumval(e._entry_result.cmapResult.resultCode))
                        if not res and e._entry_result.cmapResult.resultCode:
                            self.log.error('Class-map result ' + OnepStatus.enumval(e._entry_result.cmapResult.resultCode))
                            res = e._entry_result.cmapResult.resultCode
                    for m in e._entry_result.matchResultList:
                        self.log.debug('Match result ' + OnepStatus.enumval(m.result))
                        if not res and m.result:
                            self.log.error('Match result ' + OnepStatus.enumval(m.result))
                            res = m.result

                    for a in e._entry_result.actionResultList:
                        self.log.debug('Action result ' + OnepStatus.enumval(a.result))
                        if not res and a.result:
                            self.log.error('Action result ' + OnepStatus.enumval(a.result))
                            res = a.result

                self._result.resultCode = res

            return self._result.resultCode


    _doc_result_code = '\n        Gets the value of result code. Code 0 indicates success \n        any other values indicates failure.\n        \n        @type: C{int}\n        '
    result_code = property(_get_result_code, None, None, _doc_result_code)

    def _get_result_text(self):
        if self._result:
            self._get_result_code()
            return OnepStatus.enumval(self._result.resultCode)
        return 'No results'


    _doc_result_text = '\n        Gets the top-level status of a bulk service invocation.\n        This status indicates the overall status of the top-level result \n        in the returned result structure. Application can call \n        result_code for detailed result code.\n        <p>\n        \n        @return String Value of OnepStatus<onep.core.util.OnepStatus> result. \n        Success if status is ONEP_OK, Fail otherwise\n        \n        @type: C{str}\n        '
    result_text = property(_get_result_text, None, None, _doc_result_text)

    def create_entry(self, class_map = None):
        """ Construct a new Entry for policy map. 
                
                If this function is used, the method add_classmap must be used in order for PolicyMap to work
                when submitting to the Network Element.
                
                @param class_map: The ClassMap object.
                @type class_map: L{ClassMap<onep.policyservice.ClassMap.ClassMap>}
                
                @return: Returns an Entry object.
                     
                @rtype: L{PolicyMap.Entry<onep.policyservice.PolicyMap.PolicyMap.Entry>}
        
                @raise OnepIllegalArgumentException: If class_map is invalid.        
                """
        entry = Entry()
        entry.class_map = class_map
        entry.cap_actions = self.capabilities.actions
        entry.cap_matches = self.capabilities.matches
        self._entries.append(entry)
        return entry



    def get_entry_list(self):
        """ Gets all entries in the policy map.
            
            @return: List of Entry objects, returns None if no entry is added.
        
            @rtype: list of L{PolicyMap.Entry<onep.policyservice.PolicyMap.PolicyMap.Entry>}
            """
        if len(self._entries) > 0:
            return self._entries



    def remove_entry(self, *entries):
        """ Removes entries from the policy map.
                
                Removes only the entries that are added to policy map. 
                
                @param entries: The entries.
                @type entries: Variable length argument list of Entry
        
                """
        if len(entries) == len(self._entries):
            raise OnepIllegalArgumentException('Must have at least one Entry')
        for entry in entries:
            for i_entry in self._entries:
                if entry == i_entry:
                    i_entry._entry_op_code = Entry._entry_op_type.ENTRY_REM
                    break





    def _change_entry_op_code(self, op_code):
        """
        """
        for entry in self._entries:
            if entry._order == Entry._onep_order.ONEP_POLICY_ORDER_BEFORE:
                entry._entry_op_code = Entry._entry_op_type.ENTRY_ADD
            elif entry._entry_op_code != Entry._entry_op_type.ENTRY_REM and entry._entry_op_code != Entry._entry_op_type.ENTRY_REP_ALL_ACTIONS:
                entry._entry_op_code = op_code




    def _set_result_idl(self, result):
        """
        """
        if result == None:
            self._result = None
        else:
            self._result = result
            self._handle = result.pmapHandle
            entry_results = result.entryResult
            if entry_results != None and len(self._entries) == len(entry_results):
                for (i, entry,) in enumerate(self._entries):
                    entry._set_entry_result_idl(entry_results[i])




    def _get_result_idl(self):
        """
        """
        return self._result



    def _to_idl(self):
        """
        """
        entries_idl = []
        for entry in self._entries:
            entries_idl.append(entry._to_idl())

        pmap = PmapIDL(self.storage_type, self._handle, self._op_code, 0, entries_idl)
        if self.name:
            pmap.pmap_name = self.name
        if self.op_id:
            pmap.opId = self.op_id
        return pmap



    @classmethod
    def _from_idl(cls, idl, type, element):
        """
        """
        if idl == None:
            return 
        cap = PolicyCapabilities(type, element)
        cap._handle = idl.table_handle
        new_policy_map = PolicyMap(cap, idl.pmap_name, idl.dsid)
        new_policy_map.handle = idl.pmapHandle
        entry_idl_list = idl.entryList
        for entry_idl in entry_idl_list:
            temp_entry = new_policy_map.create_entry()
            action_idl_list = entry_idl.actionList
            action_list = Action._from_idl_list(action_idl_list, element)
            temp_entry._action_list = action_list
            match_idl_list = entry_idl.matchList
            match_list = Match._from_idl_list(match_idl_list, element)
            temp_entry._match_list = match_list
            new_policy_map._entries.append(temp_entry)

        return new_policy_map



    def _to_idl_list(cls, inst_list):
        """
        """
        if inst_list == None:
            return []
        idl_list = []
        for map in inst_list:
            idl_list.append(map._to_idl())

        return idl_list



    def _from_idl_list(cls, idl_list, element):
        """
        """
        if idl_list == None:
            return list()
        policy_maps = list()
        for idl in idl_list:
            policy_maps.append(PolicyMap._from_idl(idl, element))

        return policy_maps



    def get_result_detail(self):
        """
        Gets the results from policy submit/update/delete operations
        """
        if self._get_result_idl() and hasattr(self._get_result_idl(), '__dict__'):
            return self._genetate_dict_from_result_idl(self._get_result_idl())



    def _genetate_dict_from_result_idl(self, obj):
        if obj is None:
            return 
        else:
            if hasattr(obj, '__dict__'):
                return self._expand_dict_from_result_idl(obj.__dict__)
            if isinstance(obj, types.ListType):
                return self._expand_list_from_result_idl(obj)
            return obj



    def _expand_dict_from_result_idl(self, idl_map):
        if idl_map is None:
            return 
        new_map = {}
        for (k, v,) in idl_map.iteritems():
            if hasattr(v, '__dict__'):
                new_map[k] = self._expand_dict_from_result_idl(v.__dict__)
            elif isinstance(v, types.ListType):
                new_map[k] = self._expand_list_from_result_idl(v)
            else:
                new_map[k] = v

        return new_map



    def _expand_list_from_result_idl(self, idl_list):
        if idl_list is None:
            return 
        new_list = []
        for v in idl_list:
            if hasattr(v, '__dict__'):
                new_list.append(self._expand_dict_from_result_idl(v.__dict__))
            elif isinstance(v, types.ListType):
                new_list.append(self._expand_list_from_result_idl(v))
            else:
                new_list.append(v)

        return new_list



    def __str__(self):
        return '\n        Policy Map %s\n        -------------\n        handle  - %d\n        entries - %s\n        ' % (self.name, self.handle, str(self.get_entry_list()))




class Entry(object):
    """ 
    Entry class.
    
    This class is a container for matches and and actions Matches
    may be applied directly to the Entry or by reference using a
    ClassMap.
    
    There can only be one ClassMap per Entry, but each PolicyMap
    can have multiple Entries with different ClassMap.
    
    The Entry can have only one match of a given type.
    
    Actions are applied directly to the Entry. An Entry with
    directly applied matches can be used for Open Flow or DPSS
    programming.
    
    @undocumented: add_action
    @undocumented: handle
    @undocumented: get_action_list
    @undocumented: get_match_list
    
    """

    _onep_order = enum('ONEP_POLICY_ORDER_END', 'ONEP_POLICY_ORDER_BEFORE', 'ONEP_POLICY_ORDER_DEFAULT', 'ONEP_POLICY_ORDER_SEQUENCE')
    _entry_op_type = enum(ENTRY_ADD=0, ENTRY_MOD=1, ENTRY_REM=2, ENTRY_GET=5, ENTRY_REP_ALL_ACTIONS=8)

    def _set_match_all(self, match_all):
        try:
            self._validate_match_all(match_all)
        except OnepIllegalArgumentException as e:
            raise e
        self._match_all = match_all



    def _get_match_all(self):
        return self._match_all


    _doc_match_all = ' Match criteria.\n    \n    Property determines how packets are evaluated when multiple match criteria exist.\n\n    If set to true, matches in an entry will be based on the logical AND function,\n    otherwise matches will be based on the logical OR function.\n\n    Default Value of property: True\n    \n    Raises: OnepIllegalArgumentException - If match_all value is invalid.\n        \n    @type: C{bool}\n    '
    match_all = property(_get_match_all, _set_match_all, None, _doc_match_all)

    def _set_priority(self, bandwidth):
        try:
            self._validate_priority(bandwidth)
        except OnepIllegalArgumentException as e:
            raise 
        self._priority = priority



    def _get_priority(self):
        return self._priority


    _doc_priority = ' Bandwidth (in kbps) to be given to the priority traffic.\n    \n    This sets the priority for the priority traffic.\n    \n    This is the amount of guaranteed bandwidth value, in kbps, that will given to the priority traffic.\n    \n    Default Value of property: 0\n    \n    Raises: OnepIllegalArgumentException - If priority value is invalid.\n        \n    @type: C{int}\n    '
    priority = property(_get_priority, _set_priority, None, _doc_priority)

    def _set_class_map(self, class_map):
        try:
            if class_map:
                validate(class_map, ClassMap)
        except OnepIllegalArgumentException as e:
            raise e
        self._class_map = class_map



    def _get_class_map(self):
        return self._class_map


    _doc_class_map = ' ClassMap in the entry.\n    \n    Raises: OnepIllegalArgumentException - If class_map is invalid.\n        \n    @type: L{ClassMap<onep.policyservice.ClassMap.ClassMap>}\n    '
    class_map = property(_get_class_map, _set_class_map, None, _doc_class_map)

    def _validate_sequence(self, sequence):
        if sequence == None:
            raise OnepIllegalArgumentException('Sequence number', 'None')
        if not isinstance(sequence, int):
            raise OnepIllegalArgumentException('Sequence number is not of type int')
        if sequence < 0:
            raise OnepIllegalArgumentException('Sequence number', 'negative')



    def __init__(self):
        """ Constructor of Class Entry.
        """
        self.log = logging.getLogger('onep')
        self._match_list = []
        self._action_list = []
        self._match_all = True
        self._priority = 0
        self._class_map = None
        self._entry_handle = 0
        self._entry_result = None
        self._order = self._onep_order.ONEP_POLICY_ORDER_END
        self._sequence = 0
        self._entry_op_code = self._entry_op_type.ENTRY_ADD
        self._policy_op_index = 0
        self.cap_actions = []
        self.cap_matches = []



    @property
    def handle(self):
        return self._handle



    @handle.setter
    def handle(self, handle):
        self._handle = handle



    def set_insert_sequence(self, sequence):
        """ Insert an entry in policy by sequence number.
            
            Lower sequence numbers have higher precedence.
            
            @param sequence: Position of entry in policy.
            @type sequence: C{int}
        
            @raise OnepIllegalArgumentException: If sequence number is invalid.
            """
        self._validate_sequence(sequence)
        self._sequence = sequence
        self._order = PolicyMap.Order.ONEP_POLICY_ORDER_SEQUENCE



    def add_match(self, *matches, **kwargs):
        """
                Adds match(es) to the entry.
            
                @param matches: The matches.
                @type matches: Variable length argument list of Match
        
                """
        if self._class_map:
            raise OnepIllegalArgumentException('ClassMap object in Entry')
        negate = False
        if kwargs:
            negate = kwargs[negate]
        for match in matches:
            if isinstance(match, Match):
                if not match.check_match_support(self.cap_matches):
                    raise OnepNotSupportedException(MatchType.enumval(match.get_match_type()))
                if match not in self._match_list:
                    if match.dependent_match:
                        match.dependent_match.set_negate(negate)
                        match.dependent_match._op_code = Match.MatchOpCode.ADD
                        self._match_list.append(match.dependent_match)
                    match.set_negate(negate)
                    match._op_code = Match.MatchOpCode.ADD
                    self._match_list.append(match)




    def add_match_not(self, *matches):
        """
                Adds matches which specify the match criterion as an unsuccessful match criterion.
                
                This is equivalent to CLI "match not <match-criterion>"
                
                @param matches: The matches.
                @type matches: Variable length argument list of Match
        
                """
        self.add_match(negate=True, *matches)



    def remove_match(self, *matches):
        """ Removes match(es) from the entry.
            
            Removes only the matches that are added to entry. 
        
            @param matches: The matches.
            @type matches: Variable length argument list of Match
            """
        if self._class_map:
            raise OnepIllegalArgumentException('ClassMap object in Entry')
        if not matches:
            raise OnepIllegalArgumentException('No matches passed in')
        if len(matches) == len(self._match_list):
            raise OnepIllegalArgumentException('Must have at least one match in Entry')
        for match in matches:
            if not isinstance(match, Match):
                raise OnepIllegalArgumentException(type(Match), type(match))
            if match not in self._match_list:
                raise OnepIllegalArgumentException(str(match) + ' not in match list')

        for match in matches:
            match._op_code = Match.MatchOpCode.DEL




    def get_match_list(self):
        """ Gets all matches in the entry.
        
        @return: List of Match objects, returns None if no action is added.
         
        @rtype: C{list} of Match objects.
        """
        return self._match_list



    def add_action(self, *actions):
        """
                Adds actions to the Entry class.
                
                @param actions: One or more Action classes
                @type actions: L{Action<action.Action>}
        
                """
        if not actions:
            raise OnepIllegalArgumentException('Missing actions parameter')
        for action in actions:
            if isinstance(action, Action) and action not in self._action_list:
                if not action.check_action_support(self.cap_actions):
                    raise OnepNotSupportedException('Action ' + ActionType.enumval(action.get_action_type()))
            else:
                raise OnepIllegalArgumentException(type(Action), type(action))

        for action in actions:
            if action.dependent_action:
                action.dependent_action.op_code = Action.ActionOpCode.CREATE
                self._action_list.append(action.dependent_action)
                self.log.info('Entry.add_action dependent ' + str(action))
            action.op_code = Action.ActionOpCode.CREATE
            self._action_list.append(action)
            self.log.info('Entry.add_action ' + str(action))




    def remove_action(self, *actions):
        """
                Removes action(s) from the Entry class.
                
                Removes only the actions that are added to entry. 
            
                @param actions: Tuple of Action classes
                @type actions: L{Action<action.Action>}
        
                """
        if not actions:
            raise OnepIllegalArgumentException('Missing actions parameter')
        if len(actions) == len(self._action_list):
            raise OnepIllegalArgumentException('Must have at least one action in an entry')
        for action in actions:
            if not isinstance(action, Action):
                raise OnepIllegalArgumentException(type(Action), type(action))
            if action not in self._action_list:
                raise OnepIllegalArgumentException(str(action) + ' action is not in Entry')

        for action in actions:
            action.op_code = Action.ActionOpCode.DEL




    def replace_all_actions(self, *actions):
        """
                Replaces all actions in Entry class with the new actions passed in.
        
                @param actions: Tuple of Action classes
                @type actions: L{Action<action.Action>}
        
                """
        if not actions:
            raise OnepIllegalArgumentException('Missing actions parameter')
        self.log.info('Entry.replace_all_actions with ' + str(actions))
        saved_action_list = self._action_list
        self._action_list = []
        try:
            self.add_action(*actions)
            self._entry_op_code = self._entry_op_type.ENTRY_REP_ALL_ACTIONS
        except Exception as e:
            self._action_list = saved_action_list
            raise e



    def get_action_list(self):
        """ Gets all actions in the entry.
        
        @return: List of Action objects, returns None if no action is added.
         
        @rtype: C{list} of Action objects.        
        """
        return self._action_list



    def _set_entry_result_idl(self, result):
        """
        """
        if result == None:
            self._entry_result = None
        else:
            self._entry_result = result
            self._entry_handle = result.entryHandle
            self._policy_op_index = result.policy_op_index



    def _get_entry_result_idl(self):
        """
        """
        return self._entry_result



    def _to_idl(self):
        """
        """
        store_type = handle = 0
        if self._class_map:
            store_type = self._class_map.storage_type
            handle = self._class_map._handle
        entry_idl = EntryIDL(store_type, self._entry_handle, self._entry_op_code, self._order, 0, int(self._match_all), self._priority, self._sequence, handle, self._policy_op_index, Match._to_idl_list(self._match_list), Action._to_idl_list(self._action_list))
        return entry_idl




class ResultAsync(object):
    """
        Header for most policy async results
    
        storage_type - onep.policyservice.StorageType enum
        handle       - PolicyMap handle
        opid         - Client context ID
        opcode       - onep.policyservice.PolicyMap.Operations enum
        result       - onep.core.util.OnepStatus enum (optional)
        result_text  - Extra text about result (optional)
    
        """


    def __init__(self, result):
        self.storage_type = result.dsid
        self.result_text = self.handle = self.opid = self.opcode = None
        self.result = 0
        if hasattr(result, 'handle'):
            self.handle = result.handle
        if hasattr(result, 'pmapHandle'):
            self.handle = result.pmapHandle
        if hasattr(result, 'opid'):
            self.opid = result.opid
        if hasattr(result, 'opId'):
            self.opid = result.opId
        if hasattr(result, 'opcode'):
            self.opcode = result.opcode
        if hasattr(result, 'result'):
            self.result = result.result
        if hasattr(result, 'result_text'):
            self.result_text = result.result_text



    def __str__(self):
        return '\n        RESULT : %s\n        ' % OnepStatus.enumval(self.result)




class EntryResultAsync(ResultAsync):
    """
        Entry results returned by PolicySubmitEvent
    
        storage_type - onep.policyservice.StorageType enum
        handle       - PolicyMap handle
        opid         - Client context ID
        opcode       - onep.policyservice.PolicyMap.Operations enum
        result       - onep.core.util.OnepStatus enum (optional)
        result_text  - Extra text about result (optional)
        policy_op_index    - operation index
        class_result       - list of ClassResultAsync classes
        match_list_result  - list of ResultAsync classes
        action_list_result - list of ResultAsync classes
    
        """


    def __init__(self, result):
        super(EntryResultAsync, self).__init__(result)
        self.policy_op_index = result.policy_op_index
        self.class_result = None
        if result.cmapResult:
            self.class_result = ClassResultAsync(result.cmapResult)
        self.match_list_result = []
        for mtch in result.matchResultList:
            self.match_list_result.append(ResultAsync(mtch))

        self.action_list_result = []
        for act in result.actionResultList:
            self.action_list_result.append(ResultAsync(act))




    def __str__(self):
        res_str = ''
        for res in self.match_list_result:
            res_str = res_str + str(res)

        res_str = ''
        for res in self.action_list_result:
            res_str = res_str + str(res)

        return '\n        Entry Results\n        -------------\n        handle - %d\n        opid   - %s\n        result - %s\n\n        %s' % (self.handle,
         str(self.opid),
         OnepStatus.enumval(self.result),
         res_str)




class PolicyResultAsync(ResultAsync):
    """
        Policy results returned by PolicySubmitEvent
    
        storage_type - onep.policyservice.StorageType enum
        handle       - PolicyMap handle
        opid         - Client context ID
        opcode       - onep.policyservice.PolicyMap.Operations enum
        result       - onep.core.util.OnepStatus enum (optional)
        result_text  - Extra text about result (optional)
        entry_result_list - list of EntryResultAsync classes
        stat_result_list  - list of PolicyStatistics classes
    
        """


    def __init__(self, result):
        super(PolicyResultAsync, self).__init__(result)
        self.entry_result_list = []
        for entry in result.entryResult:
            self.entry_result_list.append(EntryResultAsync(entry))

        self.stat_result_list = []
        if result.statsResult:
            for stat in result.statsResult:
                self.stat_result_list.append(PolicyStatistics(stat.dsid, stat.asyncHandle, stat.pmapHandle, stat.ifHandle, stat.total_count, stat.entry_count, stat.more, stat.entryStatsResultList))

        self.stat_handle = result.statsResultEventHandle



    def __str__(self):
        res_str = ''
        for res in self.entry_result_list:
            res_str = res_str + str(res)

        return '\n        Policy Event\n        -----------\n        handle - %d\n        opid   - %s\n        result - %s\n\n        %s' % (self.handle,
         str(self.opid),
         OnepStatus.enumval(self.result),
         res_str)




class ActivateResultAsync(ResultAsync):
    """
        Activate results from PolicyActivateEvent
    
        storage_type - onep.policyservice.StorageType enum
        handle       - PolicyMap handle
        opid         - Client context ID
        result       - onep.core.util.OnepStatus enum (optional)
        result_text  - Extra text about result (optional)
        activate_result_list - list of dict with target class and result
            [{target class : result}, {target class : result}, ...]
    
        """


    def __init__(self, result, result_targets):
        super(ActivateResultAsync, self).__init__(result)
        self.activate_result_list = result_targets




class PolicyEvent(AsyncMsg):
    """
        Policy asynchronous event parent class
    
        """


    def __init__(self, element, base, result, type, reslist):
        self.log = logging.getLogger(__name__)
        self.log.info('Policy Event asyncHandle %d', base.asyncHandle)
        super(PolicyEvent, self).__init__(element, AsyncMsg.OnepAsyncMsgType.ONEP_ASYNC_MESSAGE_TYPE_APICALL)
        self.event_handle = base.asyncHandle
        self.result = result
        self.type = type
        self.policy_result_list = []
        self.reslist = reslist



    def do_event(self, element):
        """
                This method invokes the client's PolicyEventListener class.
        
                @param element: The NetworkElement class associated to event.
                @type element: L{NetworkElement<onep.element.NetworkElement>}
        
                """
        self.log.info('Policy Event do_event')
        (tgt_listener, app_context, objects,) = element.event_manager.bulk_listener_map.get(self.event_handle, None)
        if tgt_listener:
            self.log.info('Policy Event listener found')
            pop_event = self.event_process(self.reslist, objects)
            tgt_listener.handle_event(self, app_context)
            if pop_event:
                self.log.info('Pop Policy Event')
                element.event_manager.bulk_listener_map.pop(self.event_handle)




class PolicySubmitEvent(PolicyEvent):
    """
        Policy asynchronous event class
    
        result - enum onep.core.util.OnepStatus
        type   - Class type
        policy_result_list - List of classmap.PolicyResultAsync classes
    
        """


    def event_process(self, reslist, objects):
        for (i, rslt,) in enumerate(reslist):
            objects[i].handle = rslt.handle
            self.policy_result_list.append(PolicyResultAsync(rslt))

        return True




class PolicyActivateEvent(PolicyEvent):
    """
        Policy asynchronous event class
    
        result - enum onep.core.util.OnepStatus
        type   - Class type
        policy_result_list - List of classmap.PolicyResultAsync classes
    
    
        """


    def event_process(self, reslist, objects):
        for (i, rslt,) in enumerate(reslist):
            result_targets = {}
            for target in objects[i]._targe_array:
                target_class = None
                if hasattr(rslt, 'ifHandle'):
                    target_class = target._get_target_by_xoshandle(rslt.ifHandle)
                if hasattr(rslt, 'zpName'):
                    target_class = target._get_target_by_name(rslt.zpName)
                if target_class:
                    result_targets[target_class] = rslt[i].resultCode

            self.policy_result_list.append(ActivateResultAsync(rslt, result_targets))

        return True




class PolicyStatsEvent(PolicyEvent):
    """
        Policy asynchronous event class
    
        result - enum onep.core.util.OnepStatus
        type   - Class type
        policy_result_list - List of classmap.PolicyResultAsync classes
    
    
        """


    def __init__(self, element, sess_handle, event_handle, reslist):
        super(PolicyEvent, self).__init__(element, AsyncMsg.OnepAsyncMsgType.ONEP_ASYNC_MESSAGE_TYPE_APICALL)
        self.log = logging.getLogger(__name__)
        self.log.info('Policy Stat Event asyncHandle %d', event_handle)
        self.event_handle = event_handle
        self.session_handle = sess_handle
        self.reslist = reslist



    def event_process(self, reslist, objects):
        self.log.info('get policy stats')
        self.filters = objects
        for filter in self.filters:
            stat = reslist
            stat_targets = []
            for target in filter.targets:
                if hasattr(stat, 'ifHandle'):
                    stat_targets.append(target._get_target_by_xoshandle(stat.ifHandle))
                if hasattr(stat, 'zpName'):
                    stat_targets.append(target._get_target_by_name(stat.zpName))

            filter.stats_result.append(PolicyStatistics(stat.dsid, stat.asyncHandle, stat.pmapHandle, stat_targets, stat.total_count, stat.entry_count, stat.more, stat.entryStatsResultList))
            filter.entry_start = stat.entry_count
            filter.more = stat.more

        return False




class PolicySubmitListener(EventListener):
    """
        Listener to register for recieving Policy Submission events
    
        """

    __metaclass__ = ABCMeta

    @abstractmethod
    def handle_event(self, event, app_context):
        """ 
        Invoked when a Policy event is received from the network element.
            
        @param event: An event object which indicates that an event occurred
        in a network element
        @type event: L{onep.policyservice.policymap.PolicySubmitEvent>}
            
        @param app_context: The app_context is an object that was passed in when
        application called an API to add/register the event listener.
        The application is responsible for casting the input app_context
        to the appropriate class before using it. 
        """
        pass




class PolicyActivateListener(EventListener):
    """
        Listener to register for recieving Policy Submission events
    
        """

    __metaclass__ = ABCMeta

    @abstractmethod
    def handle_event(self, event, app_context):
        """ 
        Invoked when a Policy event is received from the network element.
            
        @param event: An event object which indicates that an event occurred
        in a network element
        @type event: L{onep.policyservice.policymap.PolicyActivateEvent>}
            
        @param app_context: The app_context is an object that was passed in when
        application called an API to add/register the event listener.
        The application is responsible for casting the input app_context
        to the appropriate class before using it. 
        """
        pass




class PolicyStatsListener(EventListener):
    """
        Listener to register for recieving Policy Statistic events
    
        """

    __metaclass__ = ABCMeta

    @abstractmethod
    def handle_event(self, event, app_context):
        """ 
        Invoked when a Policy statistic event is received from the network element.
            
        @param event: An event object which indicates that an event occurred
        in a network element
        @type event: L{onep.policyservice.policymap.PolicyStatsEvent>}
            
        @param app_context: The app_context is an object that was passed in when
        application called an API to add/register the event listener.
        The application is responsible for casting the input app_context
        to the appropriate class before using it. 
        """
        pass




class PolicyFilter(object):
    """
        Filter for policy map gets
    
        You can retrieve batches of PolicyMaps by setting "max_entry_count"
        and passing in the same PolicyFilter instance until all PolicyMaps
        are collected.
    
        policy_type        - PolicyCapabilities.PolicyCapabilitiesType
        storage_type       - StorageType (default StorageType.TRANSIENT)
        policy_handle      - PolicyMap handle to get details of PolicyMap (optional)
        targets            - list of Target classes (optional)
        max_entry_count    - Maximum entries retrieved (used for batching)
    
        pmap_result  - list of PolicyMap classes
        
        @undocumented: __init__
        @undocumented: policy_type
        @undocumented: storage_type
        @undocumented: policy_handle
        """


    def __init__(self, policy_type, storage_type = StorageType.TRANSIENT, policy_handle = 0, targets = [], _entry_start = 0, max_entry_count = 0):
        self._entry_start = _entry_start
        self._direction = None
        self.log = logging.getLogger(__name__)
        self.policy_type = policy_type
        self.storage_type = storage_type
        self.policy_handle = policy_handle
        self.targets = targets
        self.max_entry_count = max_entry_count
        self.policy_result = []



    @property
    def policy_type(self):
        return self._policy_type



    @policy_type.setter
    def policy_type(self, type):
        if not PolicyCapabilitiesType._is_valid(type):
            raise OnepIllegalArgumentException('Invalid policy type')
        self._policy_type = type



    @property
    def targets(self):
        return self._targets



    @targets.setter
    def targets(self, tgts):
        for (i, tgt,) in enumerate(tgts):
            if not isinstance(tgt, Target):
                raise OnepIllegalArgumentException('target at index %d is not Target class' % i)
            if not Target.TargetLocation._is_valid(tgt.location):
                raise OnepIllegalArgumentException('target direction is invalid')
            if not self._direction:
                self._direction = tgt.location
            elif self._direction != tgt.location:
                raise OnepIllegalArgumentException('target direction must be same for all targets')

        self._targets = tgts



    def _to_idl(self):
        if not self._direction:
            dir = 0
        else:
            dir = self._direction
        return PolicyFilterIDL(self.storage_type, 0, 0, 0, 0, self.policy_type, [ tgt.network_interface.xos_handle for tgt in self._targets ], self.max_entry_count, 0, self._entry_start, 0, dir)



    def __str__(self):
        policy_result_str = ''
        for pol in self.policy_result:
            policy_result_str = policy_result_str + str(pol)

        if not self.policy_result:
            policy_result_str = str([])
        return '\n        policy_type        - %s\n        storage_type       - %s\n        policy_handle      - %d\n        interfaces         - %s\n        target direction   - %s\n        max_entry_count    - %d\n        entry_start        - %s\n        -----------------------\n        policy_result      - %s\n        ' % (PolicyCapabilitiesType.enumval(self.policy_type),
         StorageType.enumval(self.storage_type),
         self.policy_handle,
         [ tgt.network_interface.name for tgt in self._targets ],
         Target.TargetLocation.enumval(self._direction),
         self.max_entry_count,
         str(self._entry_start),
         policy_result_str)




class PolicyStatFilter(PolicyFilter):
    """
        Filter for policy map statistics
    
        You can retrieve batches of PolicyStatistics by setting
        "max_entry_count" and passing in the same PolicyStatFilter
        instance until all statistics are recieved.
    
        policy             - PolicyMap class to get statistics from
        targets            - list of Target classes (optional)
        statistic_category - StatisticCategory (default StatisticCategory.ALL)
        poll_interval_sec  - Polling interval per second (optional)
        poll_interval_msec - Polling interval per milisecond (optional)
        max_entry_count    - Maximum entries retrieved (used for batching)
    
        stats_result - list of EntryStatistics classes
    
        """


    def __init__(self, policy, targets = [], statistic_category = StatisticCategory.ALL, poll_interval_sec = 0, poll_interval_msec = 0, _entry_start = 0, max_entry_count = 0):
        self.log = logging.getLogger(__name__)
        if not policy:
            raise OnepIllegalArgumentException('PolicyMap class required')
        super(PolicyStatFilter, self).__init__(policy.capabilities.policy_type, policy.storage_type, policy.handle, targets, _entry_start, max_entry_count)
        self.statistic_category = statistic_category
        self.poll_interval_sec = poll_interval_sec
        self.poll_interval_msec = poll_interval_msec
        self.stats_result = []



    def _to_idl(self):
        if not self._direction:
            dir = 0
        else:
            dir = self._direction
        return PolicyFilterIDL(self.storage_type, 0, 0, self.poll_interval_sec, self.poll_interval_msec, self.policy_type, [ tgt.network_interface.xos_handle for tgt in self._targets ], self.max_entry_count, 0, self._entry_start, self.statistic_category, dir)



    def __str__(self):
        stat_result_str = ''
        for stat in self.stats_result:
            stat_result_str = stat_result_str + str(stat)

        if not self.stats_result:
            stat_result_str = str([])
        return ' \n        policy_type        - %s\n        storage_type       - %s\n        policy_handle      - %d\n        interfaces         - %s\n        target direction   - %s\n        statistic_category - %s\n        poll_interval_sec  - %d\n        poll_interval_msec - %d\n        max_entry_count    - %d\n        entry_start        - %d\n        -----------------------\n        stats_result       - %s\n        ' % (PolicyCapabilitiesType.enumval(self.policy.capabilities.policy_type),
         StorageType.enumval(self.policy.storage_type),
         self.policy.handle,
         [ tgt.network_interface.name for tgt in self._targets ],
         Target.TargetLocation.enumval(self._direction),
         StatisticCategory.enumval(self.statistic_category),
         self.poll_interval_sec,
         self.poll_interval_msec,
         self.max_entry_count,
         self.entry_start,
         stat_result_str)




# decompiled 1 files: 1 okay, 0 failed, 0 verify failed
# 2015.02.05 17:22:54 IST
